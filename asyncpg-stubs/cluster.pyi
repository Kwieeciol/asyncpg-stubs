import asyncio
import subprocess
import tempfile
import typing
import typing_extensions

from . import connection, types

class _ConnectionSpec(typing_extensions.TypedDict):
    host: str
    port: str

def platform_exe(name: str) -> str: ...
def find_available_port() -> typing.Optional[int]: ...

class ClusterError(Exception): ...

class Cluster:
    _data_dir: str
    _pg_config_path: typing.Optional[str]
    _pg_bin_dir: typing.Optional[str]
    _pg_ctl: typing.Optional[str]
    _daemon_pid: typing.Optional[int]
    _daemon_process: typing.Optional['subprocess.Popen[bytes]']
    _connection_addr: typing.Optional[_ConnectionSpec]
    _connection_spec_override: typing.Optional[_ConnectionSpec]
    def __init__(
        self, data_dir: str, *, pg_config_path: typing.Optional[str] = ...
    ) -> None: ...
    def get_pg_version(self) -> types.ServerVersion: ...
    def is_managed(self) -> bool: ...
    def get_data_dir(self) -> str: ...
    def get_status(self) -> str: ...
    async def connect(
        self,
        loop: typing.Optional[asyncio.AbstractEventLoop] = ...,
        **kwargs: typing.Any,
    ) -> connection.Connection[typing.Any]: ...
    def init(self, **settings: str) -> str: ...
    def start(
        self,
        wait: int = ...,
        *,
        server_settings: typing.Dict[str, str] = ...,
        **opts: typing.Any,
    ) -> None: ...
    def reload(self) -> None: ...
    def stop(self, wait: int = ...) -> None: ...
    def destroy(self) -> None: ...
    def _get_connection_spec(self) -> typing.Optional[_ConnectionSpec]: ...
    def get_connection_spec(self) -> _ConnectionSpec: ...
    def override_connection_spec(self, **kwargs: str) -> None: ...
    def reset_wal(
        self, *, oid: typing.Optional[int] = ..., xid: typing.Optional[int] = ...
    ) -> None: ...
    def reset_hba(self) -> None: ...
    def add_hba_entry(
        self,
        *,
        type: str = ...,
        database: str,
        user: str,
        address: typing.Optional[str] = ...,
        auth_method: str,
        auth_options: typing.Optional[typing.Dict[str, str]] = ...,
    ) -> None: ...
    def trust_local_connections(self) -> None: ...
    def trust_local_replication_by(self, user: str) -> None: ...
    _postgres: typing.Any
    _pg_version: typing.Any
    def _init_env(self) -> None: ...
    def _connection_addr_from_pidfile(self) -> typing.Optional[_ConnectionSpec]: ...
    def _test_connection(self, timeout: int = ...) -> str: ...
    def _run_pg_config(self, pg_config_path: str) -> typing.Dict[str, str]: ...
    def _find_pg_config(self, pg_config_path: typing.Optional[str]) -> str: ...
    def _find_pg_binary(self, binary: str) -> str: ...
    def _get_pg_version(self) -> types.ServerVersion: ...

class TempCluster(Cluster):
    _data_dir: typing.Any
    def __init__(
        self,
        *,
        data_dir_suffix: typing.Optional[str] = ...,
        data_dir_prefix: typing.Optional[str] = ...,
        data_dir_parent: typing.Optional['tempfile._DirT[str]'] = ...,
        pg_config_path: typing.Optional[str] = ...,
    ) -> None: ...

class HotStandbyCluster(TempCluster):
    _master: _ConnectionSpec
    _repl_user: str
    def __init__(
        self,
        master: _ConnectionSpec,
        replication_user: str,
        *,
        data_dir_suffix: typing.Optional[str] = ...,
        data_dir_prefix: typing.Optional[str] = ...,
        data_dir_parent: typing.Optional['tempfile._DirT[str]'] = ...,
        pg_config_path: typing.Optional[str] = ...,
    ) -> None: ...
    _pg_basebackup: typing.Any
    def _init_env(self) -> None: ...
    def init(self, **settings: str) -> str: ...
    def start(
        self,
        wait: int = ...,
        *,
        server_settings: typing.Dict[str, str] = ...,
        **opts: str,
    ) -> None: ...

class RunningCluster(Cluster):
    conn_spec: _ConnectionSpec
    def __init__(self, **kwargs: str) -> None: ...
    def is_managed(self) -> bool: ...
    def get_connection_spec(self) -> _ConnectionSpec: ...
    def get_status(self) -> str: ...
    def init(self, **settings: str) -> str: ...
    def start(self, wait: int = ..., **settings: typing.Any) -> None: ...
    def stop(self, wait: int = ...) -> None: ...
    def destroy(self) -> None: ...
    def reset_hba(self) -> None: ...
    def add_hba_entry(
        self,
        *,
        type: str = ...,
        database: str,
        user: str,
        address: typing.Optional[str] = ...,
        auth_method: str,
        auth_options: typing.Optional[typing.Dict[str, str]] = ...,
    ) -> None: ...
