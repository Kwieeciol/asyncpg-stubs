import typing
import typing_extensions

from . import connection as _connection, connresource, cursor, types
from .protocol import protocol as _cprotocol

_Record = typing.TypeVar('_Record', bound='_cprotocol.Record')
_T = typing.TypeVar('_T')
_T_co = typing.TypeVar('_T_co', covariant=True)

class _Executor(typing_extensions.Protocol[_T_co]):
    def __call__(
        self, __protocol: _cprotocol.BaseProtocol[typing.Any]
    ) -> typing.Coroutine[typing.Any, typing.Any, _T_co]: ...

class PreparedStatement(connresource.ConnectionResource, typing.Generic[_Record]):
    __slots__: typing.Any
    _state: _cprotocol.PreparedStatementState[_Record]
    _query: str
    _last_status: typing.Optional[bytes]
    def __init__(
        self,
        connection: _connection.Connection[typing.Any],
        query: str,
        state: _cprotocol.PreparedStatementState[_Record],
    ) -> None: ...
    def get_name(self) -> str: ...
    def get_query(self) -> str: ...
    def get_statusmsg(self) -> typing.Optional[str]: ...
    def get_parameters(self) -> typing.Tuple[types.Type, ...]: ...
    def get_attributes(self) -> typing.Tuple[types.Attribute, ...]: ...
    def cursor(
        self,
        *args: typing.Any,
        prefetch: typing.Optional[int] = ...,
        timeout: typing.Optional[float] = ...,
    ) -> cursor.CursorFactory[_Record]: ...
    async def explain(self, *args: typing.Any, analyze: bool = ...) -> typing.Any: ...
    async def fetch(
        self, *args: typing.Any, timeout: typing.Optional[float] = ...
    ) -> typing.List[_Record]: ...
    async def fetchval(
        self,
        *args: typing.Any,
        column: int = ...,
        timeout: typing.Optional[float] = ...,
    ) -> typing.Any: ...
    async def fetchrow(
        self, *args: typing.Any, timeout: typing.Optional[float] = ...
    ) -> typing.Optional[_Record]: ...
    async def executemany(
        self,
        args: typing.Iterable[typing.Any],
        *,
        timeout: typing.Optional[float] = ...,
    ) -> None: ...
    async def __do_execute(self, executor: _Executor[_T]) -> _T: ...
    async def __bind_execute(
        self,
        args: typing.Tuple[typing.Any, ...],
        limit: int,
        timeout: typing.Optional[float],
    ) -> typing.List[_Record]: ...
    def _check_open(self, meth_name: str) -> None: ...
    def _check_conn_validity(self, meth_name: str) -> None: ...
    def __del__(self) -> None: ...
